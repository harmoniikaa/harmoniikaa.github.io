[{"title":"归来","date":"2017-10-16T11:23:51.000Z","path":"2017/10/16/归来/","text":"我回来了。因为我不愿意离开。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://harmoniikaa.top/tags/随笔/"}]},{"title":"GYM Quest Form","date":"2017-10-15T16:00:00.000Z","path":"2017/10/16/GYM-Quest-Form/","text":"GYM Quest Form 结束了。之前的GYM还剩下好多，就不去补完了吧。 GYM NAME STATUS GYM 101164 A Three Squares B Favorite music C Castle ACCEPTED D Reading Digits ACCEPTED E Exam F Letters ACCEPTED G Pokemons ACCEPTED H Pub crawl ACCEPTED I Cubes ACCEPTED J Marathon K Cutting ACCEPTED GYM 100363 A Aviation Reform B Busy Beavers ACCEPTED C Center of the Universe D Cyclic Index E New Hierarchy F Knights ACCEPTED G Nim for Three H Expected Number of Points ACCEPTED I Railroad Simulator J Subtrees ACCEPTED GYM 100741 A Queries ACCEPTED B Personal programming language ACCEPTED C Reordering Ones D Xor Sum ACCEPTED E Slicing cheese F Matrix ACCEPTED G Yet Another Median Task ACCEPTED H Packing circles I Card Jousting J Empty Circle K $n$-Way Tie ACCEPTED L Basketball ACCEPTED GYM 100792 A Anagrams B Banana Brain’s Bracelet C Colder-Hotter ACCEPTED D Delay Time E Entertainment F Flow Management G Garden Gathering ACCEPTED H Hashing ACCEPTED I Illegal or Not? J Jealousy K King’s Rout ACCEPTED L Locomotive GYM 100365 B Antipalindromic Numbers F Coins Game ACCEPTED H Peaks ACCEPTED I Tour ACCEPTED","tags":[]},{"title":"Hackerrank GCD Product","date":"2017-06-13T03:45:12.000Z","path":"2017/06/13/Hackerrank-GCD-Product/","text":"题意:求: \\prod_{i=1}^{n}{\\prod_{j=1}^{m}{gcd(i,j)}}不妨先假设$n&lt;m$首先枚举所有可能的$gcd$,记为$d$: \\prod_{d=1}^{n}{d^{f(d)}}其中,$f(d)$表示$d$这个$gcd$出现了多少次: f(d)=\\sum_{i=1}^{n}{\\sum_{j=1}^{m}{[gcd(i,j)=d]}} \\\\ =\\sum_{k=1}^{\\lfloor \\frac{n}{d} \\rfloor}{\\mu (k)\\lfloor \\frac{n}{kd} \\rfloor\\lfloor \\frac{m}{kd} \\rfloor}带入原式,可得: \\prod_{d=1}^{n}{d^{\\sum_{k=1}^{\\lfloor \\frac{n}{d} \\rfloor}{\\mu (k)\\lfloor \\frac{n}{kd} \\rfloor\\lfloor \\frac{m}{kd} \\rfloor}}}设$T=kd$,枚举$T$,则有: \\prod_{T=1}^{n}{(\\prod_{d|T}{d^{\\mu(\\frac{T}{d})}})^{\\lfloor \\frac{n}{T} \\rfloor\\lfloor \\frac{m}{T} \\rfloor}}令: g(T)=\\prod_{d|T}{d^{\\mu(\\frac{T}{d})}}因为莫比乌斯函数可以线性求出,若$g$也可以线性求出那么这道题目就可以在$O(n+\\sqrt{n}\\log n)$的复杂度下求出. 观察函数的性质,发现$g$并不满足积性.再次观察发现: $g(1)=1$. 如果$T$是某个质数的正整数次幂,设$T=p^q$,那么$g(T)=p$. 其余情况均满足$g(T)=1$. 所以可以枚举所有质数,并枚举它们的所有正整数次幂.因为质数的个数$\\pi(n) \\sim \\frac{n}{\\ln n}$,每个质数最多枚举$O(\\log n)$个幂,所以求出所有$g$的复杂度就是$O(\\frac{n}{\\ln n} \\times \\log n)=O(n)$,总时间复杂度为$O(n+\\sqrt{n}\\log n)$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define ll long long#define N 15000010#define mod 1000000007using namespace std;bool notPrime[N];int mu[N];int inv[N];int prime[N],tot;int g[N];int n,m;void linearShaker()&#123; mu[1]=1; for(int i=2;i&lt;=n;i++)&#123; if(!notPrime[i])&#123; prime[++tot]=i; mu[i]=-1; &#125; for(int j=1;(j&lt;=tot)&amp;&amp;(prime[j]*i&lt;=n);j++)&#123; notPrime[i*prime[j]]=1; if(i%prime[j]==0)&#123; mu[i*prime[j]]=0; break; &#125; mu[i*prime[j]]=-mu[i]; &#125; &#125; inv[1]=1; for(int i=2;i&lt;=n;i++) inv[i]=(-((ll)mod/i*inv[mod%i]%mod)+mod)%mod;&#125;ll ksm(ll a,ll b)&#123; ll ret=1; while(b)&#123; if(b&amp;1) ret=ret*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return ret;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); ll ans=1; if(n&gt;m) swap(n,m); linearShaker(); for(int i=1;i&lt;=n;i++) g[i]=1; for(int i=1;i&lt;=tot;i++)&#123; ll now=prime[i]; for(ll j=now;j&lt;=n;j=j*now)&#123; g[j]=now; &#125; &#125; g[0]=1; for(int i=1;i&lt;=n;i++) g[i]=(ll)g[i]*g[i-1]%mod; int next; for(int i=1;i&lt;=n;i=next+1)&#123; next=min(n/(n/i),m/(m/i)); ans=ans*ksm((ll)g[next]*ksm(g[i-1],mod-2)%mod,(ll)((ll)n/i)*((ll)m/i))%mod; &#125; printf(\"%lld\\n\",ans); return 0;&#125;","tags":[{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"http://harmoniikaa.top/tags/莫比乌斯反演/"}]},{"title":"Codeforces 814E","date":"2017-06-11T11:34:41.000Z","path":"2017/06/11/Codeforces-814E/","text":"由于题目中所给的限制,第$i$个节点到第1个节点的最短路一定只有一条,并且第$i$节点到第1个节点的最短路一定要大于第$i-1$个节点的.所以动态规划的阶段就应该是类似: f[节点][当前长度的最短路]的样子. 考虑一个图从点1开始的bfs树,会发现如果添加上一个点,要不与前一个点在同一层,要不比前一个深一层;并且新添加的节点一定与且只于上一层节点连一条边.所以可以记录$f_{i,p1,p2,c1,c2}$表示考虑到节点i,上一层有$p1$个节点还有1个度数,有$p2$个节点还有2个度数,当前层有$c1$个节点还有1个度数,有$c2$个节点还有2个度数,然后考虑新接入的节点与当前层的链接情况,就可以动态规划转移了. 时间复杂度:$O(n^5)$,空间可以滚动一维. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#define ll long long#define N 52#define mod 1000000007ll#define add(x,y) &#123;x+=(y);if((x)&gt;=mod) x-=mod;&#125;using namespace std;ll f[2][N][N][N][N];int n,d[N];int main()&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;d[i]); f[0][d[1]==2][d[1]==3][d[2]==2][d[2]==3]=1; for(int i=2;i&lt;n;i++)&#123; int cur=i&amp;1,nxt=cur^1; memset(f[nxt],0,sizeof(f[nxt])); for(int p1=0;p1&lt;=n;p1++)&#123; for(int p2=0;p1+p2&lt;=n;p2++)&#123; for(int c1=0;c1+p1+p2&lt;=n;c1++)&#123; for(int c2=0;c1+c2+p1+p2&lt;=n;c2++)&#123; if(f[cur][p1][p2][c1][c2]&lt;=0) continue; ll val=f[cur][p1][p2][c1][c2]; if(p1==0&amp;&amp;p2==0)&#123; add(f[cur][c1][c2][0][0],val); continue; &#125; for(int t=0;t&lt;=1;t++)&#123; ll w; if(t==0)&#123; w=p1; p1--; if(p1&lt;0)&#123; p1++; continue; &#125; &#125;else&#123; w=p2; p2--; if(p2&lt;0)&#123; p2++; continue; &#125;else&#123; p1++; &#125; &#125; if(d[i+1]==2)&#123; add(f[nxt][p1][p2][c1+1][c2],val*w%mod); if(c1) add(f[nxt][p1][p2][c1-1][c2],val*w*c1%mod); if(c2) add(f[nxt][p1][p2][c1+1][c2-1],val*w*c2%mod); &#125;else&#123; add(f[nxt][p1][p2][c1][c2+1],val*w%mod); if(c1) add(f[nxt][p1][p2][c1][c2],val*w*c1%mod); if(c2) add(f[nxt][p1][p2][c1+2][c2-1],val*w*c2%mod); if(c1&amp;&amp;c2) add(f[nxt][p1][p2][c1][c2-1],val*w*c1*c2%mod); if(c1&gt;=2) add(f[nxt][p1][p2][c1-2][c2],val*w*(c1*(c1-1)/2)%mod); if(c2&gt;=2) add(f[nxt][p1][p2][c1+2][c2-2],val*w*(c2*(c2-1)/2)%mod); &#125; if(t==0)&#123; p1++; &#125;else&#123; p2++; p1--; &#125; &#125; &#125; &#125; &#125; &#125; &#125; cout&lt;&lt;f[n&amp;1][0][0][0][0]&lt;&lt;endl; return 0;&#125;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://harmoniikaa.top/tags/动态规划/"}]},{"title":"UOJ 103","date":"2017-06-02T13:38:31.000Z","path":"2017/06/02/UOJ-103/","text":"回文自动机的模板题. 123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 300010using namespace std;char ch[N];int n;struct PAM&#123; int to[N][26],f[N],l[N],right[N],last,cnt; PAM()&#123;l[1]=-1;f[0]=cnt=1;&#125; void extend(int c,int n)&#123; int p=last; while(ch[n]!=ch[n-l[p]-1]) p=f[p]; if(!to[p][c])&#123; int np=++cnt,k=f[p];l[np]=l[p]+2; while(ch[n]!=ch[n-l[k]-1]) k=f[k]; f[np]=to[k][c];to[p][c]=np; &#125; right[last=to[p][c]]++; &#125; long long calc()&#123; long long ans=0; for(int i=cnt;i&gt;=0;i--) right[f[i]]+=right[i],ans=max(ans,(long long)right[i]*l[i]); return ans; &#125;&#125;P;int main()&#123; scanf(\"%s\",ch+1); n=strlen(ch+1); for(int i=1;i&lt;=n;i++) P.extend(ch[i]-'a',i); printf(\"%lld\\n\",P.calc()); return 0;&#125;","tags":[{"name":"回文自动机","slug":"回文自动机","permalink":"http://harmoniikaa.top/tags/回文自动机/"}]},{"title":"回文自动机初探","date":"2017-06-02T12:56:29.000Z","path":"2017/06/02/回文自动机初探/","text":"回文自动机是一个树形结构,利用类似Trie的存储方式来存储.它包含四个内容: 1234struct PAM&#123; int to[N][26],f[N],len[N],right[N],last,cnt; PAM()&#123;len[1]=-1;f[0]=cnt=1;&#125;&#125; 其中: 后缀自动机的每一个状态都代表了原串的一个回文子串. to数组表示转移,to[x][c]表示在自动机上的状态x所代表的回文串两边接上c这个字符,会转移到的状态. f数组表示失配,f[x]表示状态x所代表的回文串的最长回文后缀所在的状态. len数组表示长度,len[x]表示状态x所代表的回文串的长度. right数组表示次数,right[x]表示状态x所代表的回文串在原串中出现过多少次. cnt是回文自动机的状态总数,last表示原串的最大回文后缀所在的状态. 0状态以及它的后续状态表示了所有长度为偶数的回文子串,1状态以及它的后续状态表示了所有长度为奇数的回文子串.特殊的:len[1]=-1,f[0]=1. 上述是回文自动机的基本原理的重要部分. 回文自动机的构建方法与后缀自动机类似,采用增量法构建: 12345678910void extend(int c,int n)&#123; int p=last; while(ch[n]!=ch[n-len[p]-1]) p=f[p]; if(!to[p][c])&#123; int np=++cnt,k=f[p];len[np]=len[p]+2; while(ch[n]!=ch[n-len[k]-1]) k=f[k]; f[np]=to[k][c];to[p][c]=np; &#125; right[last=to[p][c]]++;&#125; 函数extend(c,n)表示在长度为n-1的原串ch的回文自动机后加上一个字符c. 首先提出一个引理:在原字符串后添加一个字符,所新增的本质不同的回文后缀的个数最多只有一个. 考虑增量法的步骤: 先找到ch的一个极长回文后缀,满足这个回文后缀之前的那个字符与c相等.应当从状态last沿着f数组向上找.假设找到的状态为p. 如果p有一个转移to[p][c],则可以直接结束,因为根据引理,ch+c的所有回文串在这个回文自动机中都存在了. 如果p没有转移to[p][c],则新建一个状态np,将p的to[p][c]指向np,np的len为p的len+2(显然).现在需要考虑np的f是什么,可以从p开始沿着f数组向上找,直到找到一个状态使得这个状态表示的回文后缀(因为p是ch的回文后缀,所以在这里找到的状态仍然是ch的回文后缀)之前的那个字符与c相等,设这个状态为k,那么就令f[np]=to[k][c]. 至此,回文自动机构建完毕,总的复杂度为均摊后的$O(n)$. 最后right数组要利用回文自动机的拓扑序来DP求解: 123void calcright()&#123; for(int i=cnt;i&gt;=0;i--) right[f[i]]+=right[i];&#125;","tags":[{"name":"随笔","slug":"随笔","permalink":"http://harmoniikaa.top/tags/随笔/"},{"name":"回文自动机","slug":"回文自动机","permalink":"http://harmoniikaa.top/tags/回文自动机/"}]},{"title":"清北集训Day6 数论","date":"2017-05-03T01:26:29.000Z","path":"2017/05/03/清北集训Day6-数论/","text":"清北集训Day6 数论 常用公式x^n \\equiv x^{min(n,n\\bmod\\phi(m)+\\phi(m))}x \\equiv z (\\bmod p) \\Leftrightarrow ax \\equiv az (\\bmod ap)素性判定随机整数a,根据费马小定理判断是否$a^{n-1}=1$,这样正确率比较低. 二次探测定理:若p是素数,x是一个整数,且$x^2\\bmod p \\equiv 1$,那么$x=\\pm 1 (\\bmod p)$,即模一个质数下,1不存在”非平凡平方根”. miller-rabbin分解$n-1=2^rd$.先随机生成一个a,判断数列: a^d,a^{2d},a^{4d},a^{8d}...a^{2^r*d}在模n意义下是否是先是一堆奇奇怪怪的数,然后是n-1,然后是一堆1.如果符合上述,则n可能是一个素数.首先n如果是素数,数列的最后一项一定是1.如果中间没有n-1而直接从某个数跳到了1,那么这个数根据二次探测定理,一定不是素数,如果最后一项不是1,那么它一定不是素数. 拓展BSGS每次从底数中提一个数出来,利用: x \\equiv z (\\bmod p) \\Leftrightarrow ax \\equiv az (\\bmod ap)提出一个数来,直到底数与模数互质,如果直到最后都不能互质,那么绝对无解. 拓展欧几里德保证|y|&lt;|a|,|x|&lt;|b|,|x|+|y|最小.","tags":[{"name":"数论","slug":"数论","permalink":"http://harmoniikaa.top/tags/数论/"},{"name":"清北集训","slug":"清北集训","permalink":"http://harmoniikaa.top/tags/清北集训/"}]},{"title":"BZOJ 4568","date":"2017-05-02T12:06:30.000Z","path":"2017/05/02/BZOJ-4568/","text":"直接链剖+线性基,这样的复杂度是$O(Q log^2 n \\times 60^2)$,看起来很大,跑得也可能非常慢.可以加入一个常数优化:合并线性基时采用启发式合并,这样的复杂度看起来会变成$O(Q log^2 n log 60 \\times 60)$,会跑得挺快．似乎使用点分治会获得更好的复杂度. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include&lt;bits/stdc++.h&gt;#define ll long long#define N 20010using namespace std; struct XXJ&#123; ll b[62]; int siz; XXJ()&#123; siz=0; memset(b,0,sizeof(b)); &#125; void insert(ll x)&#123; for(ll i=60;i&gt;=0;i--)&#123; if(x&amp;(1ll&lt;&lt;i))&#123; if(b[i]==0)&#123; b[i]=x; siz++; break; &#125; x^=b[i]; &#125; &#125; &#125; ll getmax()&#123; ll ret=0; for(ll i=60;i&gt;=0;i--)&#123; if((ret^b[i])&gt;ret)&#123; ret=ret^b[i]; &#125; &#125; return ret; &#125;&#125;; struct Node&#123; XXJ g; int l,r;&#125;t[N&lt;&lt;2]; struct Edge&#123; int to,next;&#125;e[N&lt;&lt;1]; int ne,n,q,head[N];int son[N],siz[N],dep[N],dad[N];int top[N],w[N],pos[N],tot;ll v[N]; void ins(int u,int v)&#123; ne++; e[ne].to=v; e[ne].next=head[u]; head[u]=ne;&#125; void insert(int u,int v)&#123; ins(u,v);ins(v,u);&#125; XXJ merge(XXJ A,XXJ B)&#123; if(A.siz&gt;B.siz) swap(A,B); if(B.siz==60) return B; for(int i=60;i&gt;=0;i--)&#123; if(A.b[i])&#123; B.insert(A.b[i]); &#125; &#125; return B;&#125; void dfs1(int x,int fa)&#123; siz[x]=1;dep[x]=dep[fa]+1;dad[x]=fa; for(int i=head[x];i;i=e[i].next)&#123; int v=e[i].to; if(v==dad[x]) continue; dfs1(v,x); siz[x]+=siz[v]; if(siz[v]&gt;siz[son[x]]) son[x]=v; &#125;&#125; void dfs2(int x,int chain)&#123; top[x]=chain;w[x]=++tot;pos[tot]=x; if(son[x]) dfs2(son[x],chain); for(int i=head[x];i;i=e[i].next)&#123; int v=e[i].to; if(v==dad[x]||v==son[x]) continue; dfs2(v,v); &#125;&#125; void pushup(int rt)&#123; t[rt].g=merge(t[rt&lt;&lt;1].g,t[rt&lt;&lt;1|1].g);&#125; void build(int rt,int l,int r)&#123; t[rt].l=l;t[rt].r=r; if(l==r)&#123; t[rt].g.insert(v[pos[l]]); return; &#125; int mid=(l+r)&gt;&gt;1; build(rt&lt;&lt;1,l,mid); build(rt&lt;&lt;1|1,mid+1,r); pushup(rt);&#125; XXJ query(int rt,int l,int r)&#123; if(l&lt;=t[rt].l&amp;&amp;t[rt].r&lt;=r)&#123; return t[rt].g; &#125; int mid=(t[rt].l+t[rt].r)&gt;&gt;1; if(l&lt;=mid&amp;&amp;mid&lt;r)&#123; return merge(query(rt&lt;&lt;1,l,r),query(rt&lt;&lt;1|1,l,r)); &#125; if(l&lt;=mid) return query(rt&lt;&lt;1,l,r); if(mid&lt;r) return query(rt&lt;&lt;1|1,l,r);&#125; ll find(int x,int y)&#123; XXJ ret; for(;top[x]!=top[y];x=dad[top[x]])&#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); ret=merge(ret,query(1,w[top[x]],w[x])); &#125; if(dep[x]&lt;dep[y]) swap(x,y); ret=merge(ret,query(1,w[y],w[x])); return ret.getmax();&#125; int main()&#123; scanf(\"%d%d\",&amp;n,&amp;q); for(int i=1;i&lt;=n;i++) scanf(\"%lld\",&amp;v[i]); for(int i=1;i&lt;n;i++)&#123; int u,v; scanf(\"%d%d\",&amp;u,&amp;v); insert(u,v); &#125; dfs1(1,0); dfs2(1,1); build(1,1,n); while(q--)&#123; int u,v; scanf(\"%d%d\",&amp;u,&amp;v); printf(\"%lld\\n\",find(u,v)); &#125; return 0;&#125;","tags":[{"name":"线性基","slug":"线性基","permalink":"http://harmoniikaa.top/tags/线性基/"}]},{"title":"清北集训Day5 后缀自动机","date":"2017-05-02T07:16:06.000Z","path":"2017/05/02/清北集训Day5-后缀自动机/","text":"清北集训Day5 后缀自动机 后缀自动机:可以接受所有后缀的自动机. 考虑串”abcabd”,这时候进来字符”b”和”ab”,实际上所匹配的位置是等价的,都只能匹配到{2,5}.当注意到这个问题:影响一个状态的是它能匹配到的位置,就要考虑如何去除冗余的东西. 考虑另一个串”eabcfabd”,这时候进来字符”b”和”ab”,实际上所匹配的位置是等价的,都只能匹配到{3,7}.但如果进来的是”eab”,只能匹配到{3},而如果进来的是”fab”,只能匹配到{7}.所以后缀自动机上的每一个状态,都可以代表了它能匹配到的若干的位置,就记这个位置集合为right.本质不同的right集合比较少.一个节点的right集合的大小,等于这个节点在parent树上子树中的叶子节点的个数. 除了后缀自动机上的转移边,还有另一类边叫做parent边,这些边连成一颗parent树.后缀自动机上的某一个节点的right一定是它的parent的right的子集. 可以注意到,后缀自动机每一个节点上的每一个节点都代表一系列长度相同的串.考虑另一个串”eabcfabdeabc”,注意到如果最后一个元素匹配到3”b”这个位置,并且到达后缀自动机right集合为{3,11}的节点,所能够接收的串的长度显然不会太长或太短,它是一个区间.这个区间的左端点一定是它的parent的右端点+1. 后缀自动机的点数是$O(n)$的,具体来讲是2n的.因为后缀自动机的每一个节点,parent等于这个节点的子节点至少有两个,至多进行$O(n)$次合并就可以合并出一个最大的节点. 终节点一定是若干个right集合大小为1的节点. bzoj 2555实际上就是在动态维护right集合的大小.会发现在extend的时候,会有断边,加边之类的操作,所以可以用LCT之类的数据结构来维护.","tags":[{"name":"清北集训","slug":"清北集训","permalink":"http://harmoniikaa.top/tags/清北集训/"},{"name":"后缀自动机","slug":"后缀自动机","permalink":"http://harmoniikaa.top/tags/后缀自动机/"}]},{"title":"清北集训Day5 贪心,分治","date":"2017-05-02T00:02:05.000Z","path":"2017/05/02/清北集训Day5-贪心,分治/","text":"清北集训Day5 贪心,分治 贪心例3 (bzoj 4245)按位贪心,发现前缀xor为1的位置不能作为段与段之间的分界点.于是为了保证高位一直最优,可以把不能作为分隔符的位置记录下来,然后每一位更新这个记录,最后何以作为分隔符的位置大于等于m那么一定可行. 例4第二问非常显然.令$f_{i,j}$表示,在不破坏更高位最优答案的情况下,[1,i]的区间内分成j段是否可行.枚举最后一段开始的位置为k,就可以转移.第一问去掉最后一维即可. 分治例1时间一维,x一维,y一维,求三维全部小于的点的个数.排序一维,树状数组一维,cdq一维. 例5sol(L,R)表示L到R这段物品没有选时的DP数组.然后递归去做. 例6最小乘积模型.考虑用二维平面上的点便是每一个解.每一个解所对应的答案即为该点所在的反比例函数的k值.最优解一定在凸壳上.先构造两组解,然后分治找距离这两个点所构成的直线的最远点,将凸壳构造出来,每次找到一个最远点更新一下答案.复杂度玄学. 趣题1枚举一个T,A与B的代价可以O(1)求出.C的代价也可以O(1)求出.结束. 2如果n=k,直接从高位到低位贪心.其实发现每个开关都不可能被其他的区间线性表示,所以先用贪心求出需要按下的开关数目,每次可能将需要按的开关数目+1或-1,若$i\\leq k$则停止.有方程: p_i= \\begin{cases} i & i\\leq k \\\\ \\frac{i}{n}p_{i-1}+\\frac{n-i}{n}p_{i+1} & i>k \\end{cases}","tags":[{"name":"清北集训","slug":"清北集训","permalink":"http://harmoniikaa.top/tags/清北集训/"},{"name":"贪心","slug":"贪心","permalink":"http://harmoniikaa.top/tags/贪心/"},{"name":"分治","slug":"分治","permalink":"http://harmoniikaa.top/tags/分治/"}]},{"title":"清北集训Day4 数据结构","date":"2017-05-01T00:02:51.000Z","path":"2017/05/01/清北集训Day4-数据结构/","text":"清北集训Day4 数据结构 线段树Sakuya对每个区间保存从左向右/从右向左,0/1进来之后出去是什么结果。 算术天才⑨与等差数列 (bzoj 4373)满足组成等差数列的两个要求: max(l,r)-min(l,r)=(r-l)*k 区间[l,r]差分后的gcd为k.以上两项都可以用线段树维护. 魔法少女LJJ (bzoj 4399)平衡树启发式合并可以做.可以用并查集套动态开点线段树来做.然后并查集合并时线段树合并. The Street (CodeChef MARCH14)超哥线段树. [Coci2015]Norma (bzoj 3745)右端点往右移,然后变成经典套路题.用单调队列维护一下. [清华集训2014]奇数国 (uoj 38)用一个线段树维护每段区间的积,再用一颗二进制线段树维护每个区间每个数是否出现过,维护时将两个long long或起来就可以了.这样我们只要求出区间的积,再将这段区间中出现过的每个数利用逆元修改答案即可. [清华集训2015]V (uoj 164)经过若干次操作后,每个数会变成max(A+x,B).维护这样的当前标记然后合并:max(x+a+A,max(b+A,B)).对于某个节点,维护这个节点积存的最大的max(AA+x,BB).若进行了一次max(x+A,B),则标记变为:max(x+max(A,AA),max(B,BB)).在下传标记时,将子节点的当前标记接在父节点的最大标记之前. 平衡树Dynamic Trees and Queries Solved (CodeChef)平衡树维护括号序列. wangxz与OJ (bzoj 3678)平衡树拆点. Simple Queries令A表示3次和,B表示2次和,C表示和. ans=\\frac{C^3-3BC+2A}{6}可持久化数据结构最大异或和 (bzoj 3261)用b表示前缀异或和,找的是$max(b_n \\oplus b_{p-1} \\oplus x)$用可持久化Trie树维护. Queries with Points可持久化平衡树维护扫描线. 点分治采药人的路径 (bzoj 3697)在点分dfs时,令$f_{i,j}$表示i为路径权值和,j=0/1表示是否有休息站.统计$\\sum{f_{i,j}f{-i,k}}$其中j+k&gt;0.注意特判重心是否为休息站. 小奇的树 (bzoj 3784)二分答案,然后就好做了. Union on Tree (CodeChef)动态点分治+虚树. [Zjoi2015]幻想乡战略游戏 (bzoj 3924)坑. [ZJOI2007]Hide 捉迷藏 (bzoj 1095)坑. 树链剖分QTREE 6 (CodeChef)先预处理出每个点的答案,记录如果这个点为白色/黑色,子树中的最大同色联通块为多少.每次修改一个点时,它到它同颜色的连续的最浅的祖先的路径上的每一个点都要减去一个值,它也要减去一个值.然后黑色白色一样一个树链剖分. Fibonacci Numbers on Tree (CodeChef)区间加等比数列,然后强行放在树上.","tags":[{"name":"清北集训","slug":"清北集训","permalink":"http://harmoniikaa.top/tags/清北集训/"},{"name":"线段树","slug":"线段树","permalink":"http://harmoniikaa.top/tags/线段树/"},{"name":"平衡树","slug":"平衡树","permalink":"http://harmoniikaa.top/tags/平衡树/"},{"name":"点分治","slug":"点分治","permalink":"http://harmoniikaa.top/tags/点分治/"},{"name":"动态点分治","slug":"动态点分治","permalink":"http://harmoniikaa.top/tags/动态点分治/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://harmoniikaa.top/tags/树链剖分/"}]},{"title":"HDU 1724","date":"2017-04-30T11:57:47.000Z","path":"2017/04/30/HDU-1724/","text":"辛普森自适应积分法模板12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int T;double a,b;double f(double x)&#123; return sqrt((1-(x*x)/(a*a))*(b*b));&#125;double simpson(double a,double b)&#123; double c=(a+b)/2.0; return (f(a)+4*f(c)+f(b))*(b-a)/6.0;&#125;double asr(double l,double r,double eps,double A)&#123; double c=(l+r)/2.0; double L=simpson(l,c),R=simpson(c,r); if(fabs(L+R-A)&lt;=15.0*eps) return L+R+(L+R-A)/15.0; return asr(l,c,eps/2,L)+asr(c,r,eps/2,R);&#125;int main()&#123; scanf(\"%d\",&amp;T); while(T--)&#123; int l,r; scanf(\"%lf%lf%d%d\",&amp;a,&amp;b,&amp;l,&amp;r); printf(\"%.3f\\n\",asr(l,r,1e-6,simpson(l,r))*2); &#125; return 0;&#125;","tags":[{"name":"辛普森积分","slug":"辛普森积分","permalink":"http://harmoniikaa.top/tags/辛普森积分/"}]},{"title":"清北集训Day3 计算几何","date":"2017-04-30T05:42:11.000Z","path":"2017/04/30/清北集训Day3-计算几何/","text":"清北集训Day3 计算几何 基本公式 两点间距离公式:\\frac{|Ax_0+By_0+C|}{\\sqrt{A^2+B^2}} 向量点积:|\\vec{a}|\\cdot|\\vec{b}|\\cdot cos(\\vec{a},\\vec{b})=x_1x_2+y_1y_2点积为0,向量垂直. 向量叉积:|\\vec{a}|\\cdot|\\vec{b}|\\cdot sin(\\vec{a},\\vec{b})=x_1y_2-x_2y_1叉积为正,b在a的逆时针.叉积为0,向量平行. 三角形面积:叉积/2. 质点系重心:x=\\frac{\\sum_{i=1}^{n}{m_ix_i}}{\\sum_{i=1}^{n}{m_i}}y=\\frac{\\sum_{i=1}^{n}{m_iy_i}}{\\sum_{i=1}^{n}{m_i}} 三角形重心:x=\\frac{\\sum_{i=1}^{3}{x_i}}{3}y=\\frac{\\sum_{i=1}^{3}{y_i}}{3}过重心的任何一条直线将三角形的面积等分. 多边形面积:把多边形划分成若干个三角形,对每个三角形求面积.或者从源点到多边形的每一个顶点做一个向量,把按多边形顶点逆时针排序相邻的向量与多边形的边组成的三角形的有向面积全部加起来,取绝对值除以二即可. 多边形重心:划分成三角形,每个三角形都有一个重心,每一个重心都有一个质量一个坐标,然后求一个质点系重心即可.也可以和求多边形类似的方法去做. 两直线交点:设P+vt,Q+wt,u=P-Q,则两直线交点:P+v\\frac{cross(w,u)}{cross(v,w)} 三角函数:cos(\\alpha)=cos(-\\alpha)sin(\\alpha)=-sin(-\\alpha)cos(\\alpha + \\beta)=cos(\\alpha)cos(\\beta)-sin(\\alpha)sin(\\beta)sin(\\alpha + \\beta)=sin(\\alpha)cos(\\beta)+cos(\\alpha)sin(\\beta)cos(\\frac{\\alpha}{2})=\\pm\\sqrt{\\frac{1+cos{\\alpha}}{2}}sin(\\frac{\\alpha}{2})=\\pm\\sqrt{\\frac{1-cos{\\alpha}}{2}}cos(\\alpha + \\beta)=cos(x+y)+cos(x-y)=2cos(x)cos(y)=2cos(\\frac{\\alpha + \\beta}{2})cos(\\frac{\\alpha - \\beta}{2})\\frac{a}{sin(A)}=\\frac{b}{sin(B)}=\\frac{c}{sin(C)}cos(A)=\\frac{b^2+c^2-a^2}{2bc}(x,y)->(cos(\\phi)x-sin(\\phi)y,sin(\\phi)x-cos(\\phi)y) 向量集 (bzoj 3533)会发现答案一定在凸包上,所以用线段树维护凸包,每次在凸包上三分即可.但这样复杂度太高,所以二进制分组来降低复杂度,每次修改只需要将区间右端点是r的线段树的凸包合并维护起来就可以了.","tags":[{"name":"计算几何","slug":"计算几何","permalink":"http://harmoniikaa.top/tags/计算几何/"},{"name":"清北集训","slug":"清北集训","permalink":"http://harmoniikaa.top/tags/清北集训/"}]},{"title":"清北集训Day3 网络流","date":"2017-04-30T00:02:23.000Z","path":"2017/04/30/清北集训Day3-网络流/","text":"清北集训Day3 网络流 Dinic当前弧优化:用一个数组记录一下某个点增广到哪个点了,在它之前的点不用再增广一次了. Collector’s Problem (uva 10779)考虑用一条流表示一种贴纸，不同流表示不同贴纸．对于每种贴纸建一个点，向汇点连流量为１的边．Bob从源点出发,向每种贴纸的点连流量为Bob有的数量的边.Bob的朋友可能会把k-1张贴纸给Bob,也可能需求一张贴纸.所以对于Bob的每个朋友建一个点,从每种贴纸向需求这种贴纸的Bob的朋友连流量为1的边,从每个Bob的朋友向每种他可以提供的贴纸连k-1的边.这样求出来的最大流就是不同贴纸的最大数量. Course Selection (Codechef Dec14)拆点,连边时考虑从100分扣多少分,所有限制再连边加限制. 石头剪刀布 (bzoj 2597)如果一个人赢了k场,则一定有$\\binom{k}{2}$个三元组满足不是石头剪刀布.目标为$\\sum_{i}{\\binom{k_i}{2}}$最小.每个未定比赛设一个点,每个人建点,连边,这就是一个最小增费用最大流了. Annual Parade (codechef PARADE)先跑Floyd.把每个点拆成左右两个,从源点向X连流量为1,Y向T连流量为1,X向Y相邻的连流量为1费用为边权.最小费用流. k-Maximum Subsequence Sum (codeforces 280)网络流的连边比较显然.网络流的正确性由于它可以退流以起到一个撤销的作用.用线段数树维护.如果只取一次,就取最大的.如果取两次,就把第一次取得取反,然后再取最大的.这样如果取k个也可以做了.","tags":[{"name":"清北集训","slug":"清北集训","permalink":"http://harmoniikaa.top/tags/清北集训/"},{"name":"最大流","slug":"最大流","permalink":"http://harmoniikaa.top/tags/最大流/"},{"name":"最小割","slug":"最小割","permalink":"http://harmoniikaa.top/tags/最小割/"},{"name":"费用流","slug":"费用流","permalink":"http://harmoniikaa.top/tags/费用流/"}]},{"title":"清北集训Day2 字符串","date":"2017-04-29T00:02:16.000Z","path":"2017/04/29/清北集训Day2-字符串/","text":"清北集训Day2 字符串 AC自动机基础如果当前走到的是s2,想要找一个s1,满足s1是s2的一个后缀.AC自动机fail指针的目的就是找一个比当前的节点更浅的节点,使得目标节点所代表的字符串是当前节点所代表的字符串的一个后缀. 后缀数组基础构造复杂度:$O(n^2logn)$:暴力排序$O(nlog^2n)$:二分+HASH$O(nlogn)$:倍增$O(n)$:DC3,SAMsa[i]:第i小的后缀height[i]:sa[i]与sa[i-1]的最长公共前缀 Z-BOX基础求的是每个后缀与原串的最长公共前缀.令$f_i$代表第i个后缀与原串的最长公共前缀长度.$f_1=|S|$.$f_2$暴力求.有若干j..r[j]与原串的前缀匹配.记录一个能和原串匹配且r[j]最靠右的某一个r[j].所以对于一个新的i,因为j到r[j]和某个前缀一样,所以i一定有一个k(=i-j)可以与之对应使得$f_i\\geq min(f_k,r[j]-i)$.和manacher算法类似. Problem 0.0: Question:给一个长度为n的字符串,希望你能找到一个最短的串能够循环生成这个串. Input:abcabcab Output:abc Sol:Z-BOX.找到第一个i+f[i]=n的后缀. Problem 0.1: Question:给一个长度为n的字符串,希望知道删去哪一个字符后,使得能够循环生成这个串的串的长度最小(也可以不删). Input:abcdabcab Output:d Sol:枚举一个长度,然后暴力去匹配就可以了.因为$\\sum{\\frac{1}{i}}=\\ln n$.可能第一块不对,那么用第二块匹配就可以了. Problem 1 (bzoj 2746):Fail树非常神奇的性质:往上走一定会走到它的一个后缀.求对应的Fail树上的LCA即可. Problem 2 (bzoj 2754):使用AC自动机.换一种想法,我们对所有询问串建一个AC自动机.然后对于每一个原串,在Fail树中询问.每次走到一个点,首先询问从这个点到根的所有点的权值和,然后用一个区间修改把从点到根的路径全部赋值为0,用一个树链剖分去维护它.这样是$O(log^2)$.果然是用一个LCT去替代,就可以做到log了. Problem 4:第一段后缀数组贪心.后面两段倒序拷贝一份然后后缀数组找一段连续的最小的即可. Problem 5 (poj 3376):考虑一个串aaaba,如果要找一个比它短的串放在它后面,那么长度一定为2或4,因为最后的若干位一定是自回文的(“a”,”aba”).然后对于每一个长度建两个map,存顺序和逆序哈希就可以了. Problem 6 (bzoj 3473):连在一起建后缀数组,用sliding-window来维护”至少k个字符串”这个量,然后对一个区间取min,用线段树维护. ap进制展开然后数位DP. b找循环节然后线段树. c乱搞.","tags":[{"name":"清北集训","slug":"清北集训","permalink":"http://harmoniikaa.top/tags/清北集训/"},{"name":"AC自动机","slug":"AC自动机","permalink":"http://harmoniikaa.top/tags/AC自动机/"},{"name":"后缀数组","slug":"后缀数组","permalink":"http://harmoniikaa.top/tags/后缀数组/"},{"name":"Z-BOX","slug":"Z-BOX","permalink":"http://harmoniikaa.top/tags/Z-BOX/"}]},{"title":"清北集训Day1 动态规划","date":"2017-04-28T00:04:51.000Z","path":"2017/04/28/清北集训Day1-动态规划/","text":"清北集训Day1 动态规划 数位DP基础考虑最简单的数位DP,求$[l,r]$中整数的个数.$[l,r]:r-l+1$$[1,r]:r$将r写成10进制数$r=a_1a_2a_3…a_k$设$f_{i,0/1}$表示考虑到第i位,小于还是小于等于r.$0:&lt;$$1:\\leq$然后转移:$f_{i+1,0}+=10f_{i,0}$$f_{i+1,0}+=(a_{i+1}-1)f_{i,1}$$f_{i+1,1}+=f_{i,1}$ 环套树DP基础对于环上每一个点所伸展出的子树做一次DP,然后在环上合并答案.比如求树的直径,枚举环上两点$i,j$,然后$f_{i,0}+f_{j,0}+dis(i,j)$既是答案.$O(n^2)$,随机情况$O(log^2n)$.或者把链拆开,复制一份,然后用数据结构+sliding window来解决. 仙人掌DP基础对于仙人掌的每一个环进行环上的DP,然后把它看成一个点然后向上传递即可.仙人掌DP是把章鱼DP不断拿来用,章鱼DP是把树形DP不断拿来用.找环:跑一边边双就可以找到所有环.在找出环的同时直接把动态规划给做了. 插头DP概念:轮廓线: 在不断填补缺口,在换行的时候会多出来一个.总共有nm个轮廓线.插头: 跨越某一轮廓线的画出来的线叫做插头.轮廓线上共有$m+1$个位置,可以用$k^{m+1}$来表示某一个位置是否有插头.*一个格子一定有两个插头. 动态规划的状态一般可以写作$f_{i,j,S}$表示到i,j这个位置的轮廓线,插头状态为S的DP值.转移时从(i,j)转移到(i,j+1)只与(i,j)的S中的第j+1和j+2两项相关. Question1 (hdu 1693):有一个n*m的方格图,你要在里面画一些线,要求:1.它们每一个都是一个环.2.它们覆盖满了整个图.求方案数. 本题可以直接写作$f_{i,j,S}$,其中S为$2^{m+1}$的一种状态,然后枚举状态转移. Question2 (ural 1519):有一个nm的方格图,你要在里面画一*条线,要求:1.它是一个环.2.它覆盖满了整个图.求方案数. 一个环与一个轮廓线的交点个数一定是偶数个.只考虑轮廓线上面的那一部分环,相连的两个插头分别用左右括号表示.会形成一个合法的括号序列,每一对相匹配的左右括号是相连的.考虑如下两个括号序列来理解:()X(),(())X转移的时候把一个相匹配的左右括号”()”连起来是一种不合法的情况.有两个左括号或两个右括号”((“,”))”也比较难受,因为删去两个相同种类的括号他就不是一个合法的括号序列了.所以两个左括号的做法是找到右边的左括号匹配的右括号,并改成左括号然后转移.两个右括号类似.所以共有八种情况,讨论出来就可以了.状态最好直接预处理出来然后用map把转移哈希起来. 博弈论DPS是必胜态,当且仅当至少有一个走出去的状态为必败态.S是必败态,当且仅当所有走出去的状态都是必胜态.实际上$f_S=!(f_{S1} \\&amp; f_{S2} \\&amp; f_{S3} \\&amp; … \\&amp; f_{Sk})$. Problem 1 (bzoj 2595)发现这道题用插头DP只需要考虑轮廓线上每个格子选了没有就可以了,所以事实上只需要$2^m$种状态.先考虑一个最直观的想法:$f_{i,j,S}$表示到(i,j)轮廓线上每一个格子与K个需要被选中的格子的联通状态.共有$O(nm2^{mk})$种状态.如果记录每一个格子属于哪一个联通块,因为统一行中两个相邻的格子会联通到一起,状态数即为$O(nm6^m)$级别.会发现这样有非常多的冗余状态,所以可以用最小表示法来优化状态数,每生成一个新状态,用最小表示法重新标号一下,状态数目会极具减小.这样做会稍微TLE.正解是斯坦纳树. Problem 2 (hdu 5009)$O(n^2)$非常简单．考虑答案最大不会超过n,所以如果一段区间中颜色个数超过$\\sqrt{n}$个,那么这个区间一定不要选.所以维护$\\sqrt{n}$个pointers,表示距离终点分别有$1-\\sqrt{n}$种颜色的最左区间,每次加进来新数时直接移动所有pointer,然后维护DP即可. Problem 3任何一个数都可以表示为$\\sum_{i=1}^{N}{x_i \\times 1111…1111}$.此时$\\sum {x_i}\\leq 9$将111..11对于模M分组,即统计模M为0..M-1的各有多少个,设模i的共有$y_i$个.令$f_{i,j,k}$表示前i组,当前$x_i$的和为j,模为k的方案总数.转移考虑对于第i+1组,最多还可以被分配9-j的值r,然后把r拆开分给第i+1组的若干个数,会使余数变成$k+r(i+1)$.实际上问题变成将r拆成$y_{i+1}$个数(可以为0)的方案总数.比如说$y_{i+1}=5$,$r=3$,此时3可以分成1+1+1,1+2,3三种,然后拿1+2为例,五个数中要选两个分别为1和2.对于每一种拆分的方案总数可以用插版法求.所以说有: f_{i+1,j+r,k+r(i+1)}+=f_{i,j,k}\\binom{y_{i+1}+r-1}{y_{i+1}-1}Problem 4 (Codechef SHGAME)实际上是一个4个方向4堆式子的NIM游戏.列出式子为$(x-1)\\oplus(n-x)\\oplus(y-1)\\oplus(m-y)$.前两项和后两项没有关系,开个map统计答案就行. Problem 5 (bzoj 2757)考虑质因数只能为2,3,5,7,然后做两个数位DP(因为乘积可能等于0). Problem 5 (zoj 2599)先用一个DP算出不同长度数字和为i的有多少个.然后再一次数位DP求出小于k的数字和为i的有多少个. Problem 6最简单的DP. Problem 7 (bzoj 2331)0:无插头.1:插头没转过弯.2:插头在上面转过弯.然后转移. Problem 8考虑有2M+1种插头,0插头和2M种颜色产生的括号序列.最暴力的做法.正解应该有1+M+2种插头.1:0插头.M:M种颜色.2:无颜色插头.转移:1(:左括号所对应的右括号会变成1.每次一个无颜色和一个有颜色的相连时,将所对应的括号染色.然后DP即可. Problem 9 (TC SRM 498 Div1 1000PT)考虑如果没有K种向量不能走的限制,可以直接将x轴与y轴拆开做,因为x与y的行为互不影响.令$f_{i,x,y}$表示走i步到(x,y)的方案数,不管有没有不合法的方案.如果拆开就是$f_{i,x}\\times f_{i,y}$来进行DP.令$g_{i,z}$表示走i步到(10z,10z)的方案数,只走不合法的方案.考虑$f_{R,Tx,Ty}$,枚举有走一步不合法的方案,可能走的是$k_1,k_2..k_K$,会从$f_{R-1,Tx-k_i,Ty-k}\\times R$转移来,当然也可能走两步之类的,然后用容斥原理合并起来． ans=\\sum_{i=0}^{R}{\\sum_{j=1}^{M}{f_{R-i,Tx-10j,Ty-10j} \\times g_{i,j} \\times \\binom{R}{i} \\times (-1)^i}}Problem 10先降序排序.$f_{i,j}$表示已经放进去了i个数,激动值为j的方案数.$f_{i+1,j+1}+=f_{i,j}$$f_{i+1,j}+=i\\times f_{i,j}$但是重复的不好处理.所以$f_{i,j,0/1}$表示已经放进去了i个数,激动值为j,与当前数相等的数有没有放到过开头的方案数,最后答案除以一个组合数就可以了. Problem 11显然可以$O(2^100\\times 100)$来暴力DP.枚举第一个数选什么,最多只有3个质因数.或者大于10的质数指数最大为1,把这些扣出来,剩下只剩2357,DP即可. a最暴力的DP是设$f_{i,j}$表示还剩i,上次减的是j,先手是否能赢.重新设一下,令$f_{i}$表示当前还剩i个,这一步最少减去多少我能赢.如果减去的个数大于等于s,那么一定输咯. b (Codeforces 434C)AC自动机+数位DP裸题. c令$f_{i,j,a,b,c,d,0/1}$表示前i个,总代价为j,….,有无队长的最大收益,然后把所有的按收益降序排序,以保障队长不同方案相同.统计答案即可.","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://harmoniikaa.top/tags/动态规划/"},{"name":"博弈论","slug":"博弈论","permalink":"http://harmoniikaa.top/tags/博弈论/"},{"name":"清北集训","slug":"清北集训","permalink":"http://harmoniikaa.top/tags/清北集训/"}]},{"title":"GYM 100365","date":"2017-04-25T08:17:35.000Z","path":"2017/04/25/GYM-100365/","text":"2008-2009 Winter Petrozavodsk Camp, Andrew Stankevich Contest 34 (ASC 34) B Antipalindromic Numbers比较简单. F Coins Game强行将每一个点的sg函数求出来,异或起来就是答案. 每一个点的sg的子状态实际上就是将1个点分成了三个点分别求sg然后异或起来,直接暴力即可. 注意:异或的优先级是要比”==”低的! 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define N 60using namespace std;int sg[N][N];int n,m;char ch[N];int a[N][N],c[N*N];int main()&#123; freopen(\"coins.in\",\"r\",stdin); freopen(\"coins.out\",\"w\",stdout); scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; scanf(\"%s\",ch+1); for(int j=1;j&lt;=m;j++) a[i][j]=ch[j]-'0'; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; memset(c,0,sizeof(c)); for(int i0=0;i0&lt;i;i0++)&#123; for(int j0=0;j0&lt;j;j0++)&#123; c[sg[i][j0]^sg[i0][j]^sg[i0][j0]]=1; &#125; &#125; while(c[sg[i][j]]) sg[i][j]++; &#125; &#125; int fsg=0; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; if(a[i][j]) fsg^=sg[i][j]; &#125; &#125; if(fsg)&#123; printf(\"Ann\\n\"); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; if(a[i][j])&#123; for(int i0=0;i0&lt;i;i0++)&#123; for(int j0=0;j0&lt;j;j0++)&#123; if((fsg^sg[i][j]^sg[i0][j]^sg[i][j0]^sg[i0][j0])==0)&#123; printf(\"%d %d\\n%d %d\\n\",i,j,i0,j0); return 0; &#125; &#125; &#125; &#125; &#125; &#125; while(true) cout&lt;&lt;233; &#125;else&#123; printf(\"Betty\\n\"); &#125; return 0;&#125; H Peaks考虑DP,令$f_{i,j}$表示考虑数1..i中有j个Peaks的方案总数. f_{i,j}=(i-2j+2)f_{i-1,j-1}+(2j)f_{i-1,j}考虑模数很小,打表发现,每隔56882个i,就会出现一次循环,即$f_i=f_{i-56882}$,所以这道题就可以直接做了. 1234567891011121314151617181920212223#include&lt;cstdio&gt;#define N 100010#define mod 239using namespace std;int k,f[N][40];int main()&#123; freopen(\"peaks.in\",\"r\",stdin); freopen(\"peaks.out\",\"w\",stdout); long long n; scanf(\"%lld%d\",&amp;n,&amp;k); n=n%56882; if(n==0) n=56882; f[1][1]=1; for(int i=2;i&lt;=n;i++)&#123; for(int j=1;j&lt;=30;j++)&#123; f[i][j]=((i-2*j+2)*f[i-1][j-1]+2*j*f[i-1][j])%mod; &#125; &#125; printf(\"%d\\n\",f[n][k]); return 0;&#125; I Tour分析会发现,本题实际上求得是一个树的最小链覆盖,然后把每条链首尾相连就是一个圈了.所以考虑DP:$f_{u,0},f_{u,1}$分别表示以u为根,头上是否还可以再连出去的最小链覆盖是多少.转移即枚举所有子树考虑哪一颗或哪两颗子树连向了根,然后直接统计最小值即可.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;#define N 100010#define inf 0x3f3f3f3fusing namespace std;struct Edge&#123; int to,next;&#125;e[N&lt;&lt;1];int n,ne,head[N],f[N][2];void ins(int u,int v)&#123; ne++; e[ne].to=v; e[ne].next=head[u]; head[u]=ne;&#125;void insert(int u,int v)&#123; ins(u,v);ins(v,u);&#125;void dfs(int x,int fa)&#123; int sum0=0; int mn=inf,mn2=inf; for(int i=head[x];i;i=e[i].next)&#123; int v=e[i].to; if(v==fa) continue; dfs(v,x); sum0+=f[v][0]; if(f[v][1]-f[v][0]&lt;=mn)&#123; mn2=mn; mn=f[v][1]-f[v][0]; &#125;else if(f[v][1]-f[v][0]&lt;=mn2)&#123; mn2=f[v][1]-f[v][0]; &#125; &#125; f[x][1]=f[x][0]=sum0+1; f[x][1]=min(f[x][1],sum0+mn); f[x][0]=min(f[x][0],min(sum0+mn,sum0+mn+mn2-1));&#125;int main()&#123; freopen(\"tour.in\",\"r\",stdin); freopen(\"tour.out\",\"w\",stdout); scanf(\"%d\",&amp;n); for(int i=1;i&lt;n;i++)&#123; int u,v; scanf(\"%d%d\",&amp;u,&amp;v); insert(u,v); &#125; dfs(1,0); printf(\"%d\\n\",f[1][0]); return 0;&#125;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://harmoniikaa.top/tags/动态规划/"},{"name":"博弈论","slug":"博弈论","permalink":"http://harmoniikaa.top/tags/博弈论/"}]},{"title":"GYM 100792","date":"2017-04-21T02:27:16.000Z","path":"2017/04/21/GYM-100792/","text":"2015-2016 ACM-ICPC, NEERC, Moscow Subregional Contest A AnagramsB Banana Brain’s BraceletC Colder-Hotter二分区间,然后判定即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;int guess(int x,int y)&#123; printf(\"%d %d\\n\",x,y); fflush(stdout); scanf(\"%d\",&amp;x); return x;&#125;int x,y;int main()&#123; int l=0,r=1e9,mid; while(l&lt;=r)&#123; if(l==r)&#123; x=l; break; &#125; mid=(l+r)&gt;&gt;1; guess(l,0); if(guess(r,0))&#123; l=mid+1; &#125;else&#123; r=mid; &#125; &#125; l=0,r=1e9; while(l&lt;=r)&#123; if(l==r)&#123; y=l; break; &#125; mid=(l+r)&gt;&gt;1; guess(x,l); if(guess(x,r))&#123; l=mid+1; &#125;else&#123; r=mid; &#125; &#125; printf(\"A %d %d\\n\",x,y); return 0;&#125; D Delay TimeE EntertainmentF Flow ManagementG Garden Gathering列一下式子: dis_{i,j}=(\\sqrt{2}-1)min(|x_i-x_j|,|y_i-y_j|)+max(|x_i-x_j|,|y_i-y_j|)考虑$dx$,$dy$的大小关系,$x_i$,$x_j$的大小关系,$y_i$,$y_j$的点小关系,共有8种.拆开minmax和绝对值,发现$x_i$与$x_j$的系数互为相反数,$y_i$与$y_j$的系数互为相反数,所以对于每一种情况排序然后取最大的减去最小的即可. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define Pair pair&lt;double,int&gt;#define N 200010using namespace std;int n,l,r;double x[N],y[N],ans;Pair a[N];void update(Pair A,Pair B)&#123; if(B.first-A.first&gt;ans)&#123; ans=B.first-A.first; l=A.second;r=B.second; &#125;&#125;int main()&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) scanf(\"%lf%lf\",&amp;x[i],&amp;y[i]); for(int i=1;i&lt;=n;i++) a[i]=Pair(+(sqrt(2.0)-1)*x[i]+y[i],i); sort(a+1,a+1+n); update(a[1],a[n]); for(int i=1;i&lt;=n;i++) a[i]=Pair(+(sqrt(2.0)-1)*x[i]-y[i],i); sort(a+1,a+1+n); update(a[1],a[n]); for(int i=1;i&lt;=n;i++) a[i]=Pair(-(sqrt(2.0)-1)*x[i]+y[i],i); sort(a+1,a+1+n); update(a[1],a[n]); for(int i=1;i&lt;=n;i++) a[i]=Pair(-(sqrt(2.0)-1)*x[i]-y[i],i); sort(a+1,a+1+n); update(a[1],a[n]); for(int i=1;i&lt;=n;i++) a[i]=Pair(+(sqrt(2.0)-1)*y[i]+x[i],i); sort(a+1,a+1+n); update(a[1],a[n]); for(int i=1;i&lt;=n;i++) a[i]=Pair(+(sqrt(2.0)-1)*y[i]-x[i],i); sort(a+1,a+1+n); update(a[1],a[n]); for(int i=1;i&lt;=n;i++) a[i]=Pair(-(sqrt(2.0)-1)*y[i]+x[i],i); sort(a+1,a+1+n); update(a[1],a[n]); for(int i=1;i&lt;=n;i++) a[i]=Pair(-(sqrt(2.0)-1)*y[i]-x[i],i); sort(a+1,a+1+n); update(a[1],a[n]); printf(\"%d %d\\n\",l,r); return 0;&#125; H Hashing一个显然的DP方程:设$f_{i,j}$表示考虑到第i个数,s中已有j个数它的最大hash值是多少,然后直接转移即可.用前缀和优化可以做到$O(n^2)$ 事实上a[i]数组最大仅为255,考虑$f_{i,j}$从$f_{i’,j-1}$转移过来的过程,若$i-i’\\geq 256$显然可以通过将其中所有的数全部选中以使答案更优,则$i-i’\\leq 256$.若答案中有大于256个数没有被选中,则一定可以选择其中的若干数使答案更优.所以考虑新方程:$f_{i,j}$表示考虑到第i个数,有j个数没有被选中的最大hash值是多少.$f_{i,j}$可能从$f_{i-1,j}$或$f_{i-1,j-1}$转移而来,分别表示a[i]这个数选还是不选.DP,最后统计答案即可完成本题. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define N 100010#define ll long longusing namespace std;ll f[N][300];ll a[N];int n;int getnum(char x)&#123; switch(x)&#123; case '0': return 0; case '1': return 1; case '2': return 2; case '3': return 3; case '4': return 4; case '5': return 5; case '6': return 6; case '7': return 7; case '8': return 8; case '9': return 9; case 'A': return 10; case 'B': return 11; case 'C': return 12; case 'D': return 13; case 'E': return 14; case 'F': return 15; &#125;&#125;int main()&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++)&#123; char ch[10]; scanf(\"%s\",ch); a[i]=getnum(ch[0])*16+getnum(ch[1]); &#125; for(int i=1;i&lt;=n;i++)&#123; f[i][0]=f[i-1][0]+a[i]^i; for(int j=0;j&lt;=260&amp;&amp;i-j-1&gt;=0;j++)&#123; f[i][j]=max(f[i-1][j]+(a[i]^(i-j-1)),f[i-1][j-1]); &#125; &#125; ll ans=0; for(int i=1;i&lt;=n;i++)&#123; for(int j=0;j&lt;=260;j++)&#123; ans=max(ans,f[i][j]); &#125; &#125; printf(\"%lld\\n\",ans); return 0;&#125; I Illegal or Not?J JealousyK King’s Rout反向连边,用堆来拓扑排序,得出的拓扑序再反向即可.12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define N 200010#define M 400010using namespace std;struct Edge&#123; int to,next;&#125;e[M];int n,m,ne,head[N],d[N];priority_queue&lt;int&gt; heap;vector&lt;int&gt; ans;void insert(int u,int v)&#123; ne++; e[ne].to=v; e[ne].next=head[u]; head[u]=ne; d[v]++;&#125;void topsort()&#123; for(int i=1;i&lt;=n;i++) if(d[i]==0) heap.push(i); while(!heap.empty())&#123; int x=heap.top(); ans.push_back(x); heap.pop(); for(int i=head[x];i;i=e[i].next)&#123; int v=e[i].to; d[v]--; if(d[v]==0) heap.push(v); &#125; &#125;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; int u,v; scanf(\"%d%d\",&amp;u,&amp;v); insert(v,u); &#125; topsort(); reverse(ans.begin(),ans.end()); for(int i=0;i&lt;ans.size();i++) printf(\"%d \",ans[i]);&#125; L Locomotive","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://harmoniikaa.top/tags/动态规划/"},{"name":"二分","slug":"二分","permalink":"http://harmoniikaa.top/tags/二分/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"http://harmoniikaa.top/tags/拓扑排序/"},{"name":"堆","slug":"堆","permalink":"http://harmoniikaa.top/tags/堆/"}]},{"title":"GYM 100741","date":"2017-04-20T01:05:11.000Z","path":"2017/04/20/GYM-100741/","text":"KTU Programming Camp (Day 5) A Queries开m个树状数组,然后直接做就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define N 10010#define ll long longusing namespace std;struct BIT&#123; ll c[N]; int n; int lowbit(int x)&#123; return x&amp;(-x); &#125; void modify(int x,ll y)&#123; for(;x&lt;=n;x+=lowbit(x)) c[x]+=y; &#125; ll query(int x)&#123; ll ret=0; for(;x;x-=lowbit(x)) ret+=c[x]; return ret; &#125; ll query(int l,int r)&#123; return query(r)-query(l-1); &#125;&#125;bit[20];int n,m,T;ll a[N];int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=0;i&lt;m;i++) bit[i].n=n; for(int i=1;i&lt;=n;i++)&#123; scanf(\"%lld\",&amp;a[i]); bit[a[i]%m].modify(i,a[i]); &#125; scanf(\"%d\",&amp;T); while(T--)&#123; int x,y,z; char opt[10]; scanf(\"%s%d%d\",opt,&amp;x,&amp;y); if(opt[0]=='+')&#123; bit[a[x]%m].modify(x,-a[x]); a[x]+=y; bit[a[x]%m].modify(x,a[x]); printf(\"%lld\\n\",a[x]); &#125; if(opt[0]=='-')&#123; if(a[x]&lt;y)&#123; printf(\"%lld\\n\",a[x]); &#125;else&#123; bit[a[x]%m].modify(x,-a[x]); a[x]-=y; bit[a[x]%m].modify(x,a[x]); printf(\"%lld\\n\",a[x]); &#125; &#125; if(opt[0]=='s')&#123; scanf(\"%d\",&amp;z); printf(\"%lld\\n\",bit[z].query(x,y)); &#125; &#125; return 0;&#125; B Personal programming language大力模拟DFS.在DFS的末尾处理并加入串即可.1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;#define N 100010using namespace std;map&lt;string,int&gt; pos;vector&lt;int&gt; with[N],ans;string str[N];string tmp;bool vis[N];int n;void dfs(int x)&#123; vis[x]=1; for(int i=with[x].size()-1;i&gt;=0;i--)&#123; int v=with[x][i]; if(vis[v]) continue; dfs(v); &#125; ans.push_back(x);&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;tmp; cin&gt;&gt;tmp; pos[tmp]=i; while(cin&gt;&gt;tmp)&#123; if(tmp[0]=='w')&#123; cin&gt;&gt;tmp; with[i].push_back(pos[tmp]); &#125;else&#123; cin&gt;&gt;str[i]; break; &#125; &#125; &#125; cin&gt;&gt;tmp; int x=pos[tmp]; dfs(x); for(int i=ans.size()-1;i&gt;=0;i--) cout&lt;&lt;str[ans[i]]&lt;&lt;\" \"; cout&lt;&lt;endl; return 0;&#125; C Reordering OnesD Xor Sum把所有的异或起来即可,偶数的就全异或没了. 123456789101112131415#include&lt;cstdio&gt;using namespace std;int n,ans=0;int main()&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++)&#123; int x; scanf(\"%d\",&amp;x); ans^=x; &#125; printf(\"%d\\n\",ans); return 0;&#125; E Slicing cheeseF Matrix离散化建图跑匈牙利算法. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define N 310using namespace std;bitset&lt;N*N&gt; vis;int lk[N*N],pos[N&lt;&lt;1];int tmp[N*N];int a[N][N];vector&lt;int&gt; g[N&lt;&lt;1];int n,m;bool find(int x)&#123; for(int i=0;i&lt;g[x].size();i++)&#123; int v=g[x][i]; if(vis[v]) continue; vis[v]=1; if(lk[v]==-1||find(lk[v]))&#123; lk[v]=x; return 1; &#125; &#125; return 0;&#125;int main()&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; scanf(\"%d\",&amp;a[i][j]); tmp[++m]=a[i][j]; &#125; &#125; sort(tmp+1,tmp+1+m); m=unique(tmp+1,tmp+1+m)-tmp-1; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; a[i][j]=lower_bound(tmp+1,tmp+1+m,a[i][j])-tmp; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; g[j-i+n].push_back(a[i][j]); &#125; &#125; memset(lk,-1,sizeof(lk)); for(int i=1;i&lt;=2*n-1;i++)&#123; vis=0; if(!find(i))&#123; printf(\"NO\\n\"); return 0; &#125; &#125; printf(\"YES\\n\"); for(int i=1;i&lt;=m;i++)&#123; if(lk[i]!=-1)&#123; pos[lk[i]]=i; &#125; &#125; for(int i=1;i&lt;=2*n-1;i++) printf(\"%d \",tmp[pos[i]]); printf(\"\\n\"); return 0;&#125; G Yet Another Median Task考虑直接暴力,如果能够在$O(n)$的时间之内求出给定数列的中位数,那么总时间复杂度就可以在$O(qn^2) = 1000 \\times 800^2\\approx 6.4e8$跑出来. 意识到STL中有一款nth_element,然后此题得解. 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define N 810using namespace std;inline int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;int a[N][N];int tmp[N*N];int tot=0;int n,q;int main()&#123; n=read();q=read(); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; a[i][j]=read(); &#125; &#125; while(q--)&#123; int x1,y1,x2,y2; x1=read();y1=read();x2=read();y2=read(); tot=0; for(int i=x1;i&lt;=x2;i++)&#123; for(int j=y1;j&lt;=y2;j++)&#123; tmp[++tot]=a[i][j]; &#125; &#125; nth_element(tmp+1,tmp+(tot+1)/2,tmp+1+tot); printf(\"%d\\n\",tmp[(tot+1)/2]); &#125; return 0;&#125; H Packing circlesI Card JoustingJ Empty CircleK $n$-Way Tie构造. 考虑一个竞赛图,共有$\\frac{n(n-1)}{2}$条边,每条边一定会出现一分的贡献.所以将所有边重新定向,若$n|\\frac{n(n-1)}{2}$,意思就是说将所有的得分能够平均分给每一个人,则一定存在一个解. 构造方法是让第i个人赢第i+1~i+n/2个人. 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;int n;int main()&#123; scanf(\"%d\",&amp;n); if(n%2==0)&#123; printf(\"No\\n\"); return 0; &#125; printf(\"Yes\\n\"); for(int i=1;i&lt;n;i++)&#123; for(int j=1;j&lt;=min(n/2,n-i);j++) printf(\"1 \"); for(int j=min(n/2,n-i)+1;j&lt;=n-i;j++) printf(\"0 \"); printf(\"\\n\"); &#125; return 0;&#125; L Basketball大力模拟,开两个map来做. 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;map&lt;int,int&gt; mpa,mpb;int a[20],b[20],n,m;int calca(int S)&#123; int ret=0; for(int i=0;i&lt;n;i++)&#123; if(S&amp;(1&lt;&lt;i)) ret+=a[i]; &#125; return ret;&#125;int calcb(int S)&#123; int ret=0; for(int i=0;i&lt;m;i++)&#123; if(S&amp;(1&lt;&lt;i)) ret+=b[i]; &#125; return ret;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;a[i]); for(int i=0;i&lt;m;i++) scanf(\"%d\",&amp;b[i]); for(int S=1;S&lt;(1&lt;&lt;n);S++) mpa[calca(S)]++; for(int S=1;S&lt;(1&lt;&lt;m);S++) mpb[calcb(S)]++; long long ans=0; for(map&lt;int,int&gt;::iterator it=mpa.begin();it!=mpa.end();it++)&#123; int now=it-&gt;first,k=it-&gt;second; ans+=(long long)k*mpb[now]; &#125; printf(\"%lld\\n\",ans); return 0;&#125;","tags":[{"name":"模拟","slug":"模拟","permalink":"http://harmoniikaa.top/tags/模拟/"},{"name":"构造","slug":"构造","permalink":"http://harmoniikaa.top/tags/构造/"},{"name":"树状数组","slug":"树状数组","permalink":"http://harmoniikaa.top/tags/树状数组/"},{"name":"匈牙利算法","slug":"匈牙利算法","permalink":"http://harmoniikaa.top/tags/匈牙利算法/"}]},{"title":"GYM 100363","date":"2017-04-18T02:12:59.000Z","path":"2017/04/18/GYM-100363/","text":"2008-2009 Winter Petrozavodsk Camp, Andrew Stankevich Contest 33 (ASC 33) A Aviation ReformB Busy Beavers大力模拟12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define N 100000010using namespace std;int a[20],b[20],c[20];bool p[N&lt;&lt;1];int main()&#123; freopen(\"beavers.in\",\"r\",stdin); freopen(\"beavers.out\",\"w\",stdout); for(int i=0;i&lt;10;i++)&#123; char s[10]; scanf(\"%s\",s); if(s[0]=='0')&#123; a[i]=0; &#125;else&#123; a[i]=1; &#125; if(s[1]=='L')&#123; b[i]=-1; &#125;else&#123; b[i]=1; &#125; if(s[2]=='H')&#123; c[i]=-1; &#125;else&#123; c[i]=s[2]-'A'; &#125; &#125; int nowp=N,nowm=0; for(int CASE=0;CASE&lt;N;CASE++)&#123; int k=nowm*2+p[nowp]; if(c[k]==-1)&#123; printf(\"happy beaver\\n\"); return 0; &#125; p[nowp]=a[k]; nowp=nowp+b[k]; nowm=c[k]; &#125; printf(\"unhappy beaver\\n\"); return 0;&#125; C Center of the UniverseD Cyclic IndexE New HierarchyF Knights简单的博弈论. 事实上每次两人移动完了,相当于将点从(x,y)移动到了(x-3,y-3),Andrew只能控制y,而Peter只能控制x. 所以查看一下(x,y)向哪个方向需要步数更少,判一下即可. 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define inf 0x3f3f3f3fusing namespace std;int n;int main()&#123; freopen(\"knights.in\",\"r\",stdin); freopen(\"knights.out\",\"w\",stdout); while(true)&#123; scanf(\"%d\",&amp;n); if(n==0) return 0; int mx=inf,my=inf; for(int i=1;i&lt;=n;i++)&#123; int x,y; scanf(\"%d%d\",&amp;x,&amp;y); mx=min(mx,x); my=min(my,y); &#125; int dx=(mx+1)/3; int dy=my/3; if(dx&lt;=dy)&#123; printf(\"Peter wins the game\\n\"); &#125;else&#123; printf(\"Andrew wins the game\\n\"); &#125; &#125; return 0;&#125; G Nim for ThreeH Expected Number of PointsBZOJ1913原题. 考虑每一个四边形对答案的贡献,凹四边形贡献为1,凸四边形贡献为2.所以答案即为: \\frac{2\\binom{n}{4}-C}{\\binom{n}{3}}其中C为凹四边形的个数. 然后枚举凹四边形中间点,级角排序,然后用类似two-pointers的方式统计方案即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define N 1510#define PI 3.1415926535897932384626using namespace std;struct Point&#123; long double x,y; long double arc; Point(long double _=0,long double __=0,long double ___=0)&#123; x=_;y=__;arc=___; &#125;&#125;a[N],p[N];inline Point operator - (Point A,Point B)&#123; return Point(A.x-B.x,A.y-B.y);&#125;inline long double cross(Point A,Point B)&#123; return A.x*B.y-A.y*B.x;&#125;bool cmp(Point A,Point B)&#123; return A.arc&lt;B.arc;&#125;int n,tot;long double calc(int x)&#123; long double ret=1.0*(n-1)*(n-2)*(n-3)/6.0;tot=0; for(int i=0;i&lt;n;i++) if(i!=x) a[i].arc=atan2(a[i].y-a[x].y,a[i].x-a[x].x),p[tot++]=a[i]; sort(p,p+tot,cmp); for(int i=0,j=1,t=0;i&lt;tot;i++,t--)&#123; while(cross(p[i]-a[x],p[j]-a[x])&gt;=0.0)&#123; j=(j+1)%tot;t++; if(j==i) break; &#125; ret-=t*(t-1)/2; &#125; return ret;&#125;int main()&#123; freopen(\"points.in\",\"r\",stdin); freopen(\"points.out\",\"w\",stdout); scanf(\"%d\",&amp;n); if(n==3)&#123; printf(\"0\\n\"); return 0; &#125; for(int i=0;i&lt;n;i++)&#123; double x,y; scanf(\"%lf%lf\",&amp;x,&amp;y); a[i].x=x;a[i].y=y; &#125; long double C=0; long double Cn4=1.0*n*(n-1)*(n-2)*(n-3)/24.0; long double Cn3=1.0*n*(n-1)*(n-2)/6.0; for(int i=0;i&lt;n;i++)&#123; C+=calc(i); &#125; printf(\"%.12lf\\n\",(double)((2*Cn4-C)/Cn3)); return 0;&#125; I Railroad SimulatorJ Subtrees考虑树形DP常规的思路:令$f_{i,j,0/1}$表示以i为根的子树,分成j个不相交的子树,点i选或是不选的方案数,然后枚举子树,依次分别计算贡献进行DP. 假设现在所在的子树以u为根,已经将v之前的所有儿子处理完成,现在处理的儿子是v,则它对答案的影响为: f_{u,j,0}=\\sum_{k=0}^{siz[v]}{f_{u,j-k,0}(f_{v,k,0}+f_{v,k,1})}f_{u,j,1}=\\sum_{k=0}^{siz[v]}{f_{u,j-k,1}(f_{v,k,0}+f_{v,k,1})} + \\sum_{k=0}^{siz[v]}{f_{u,j-k+1,1}f_{v,k,1}}意思是考虑(u,v)这条边选是不选,如果点u不选,则(u,v)选与不选无区别,直接用一个卷积形式统计答案即可.如果点u选,(u,v)不选,则和前面一样.如果点u选,(u,v)也选,则若点u所在子树有a颗不相交的子树,v所在子树有b颗不相交的子树,那么合并之后的子树会有a+b-1颗不相交的子树,而不是a+b颗. 初始时,$f_{u,0,0}=f_{u,1,1}=1$. 使用上述方法DP即可.复杂度为$O(n^3)$,但似乎可以使用FFT优化到$O(n^2logn)$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#define N 110#define ll long long#define mod 1000000000llusing namespace std;vector&lt;int&gt; g[N];ll f[N][N][2],tmp[N][2];int n,siz[N];void dfs(int u,int fa)&#123; siz[u]=1; f[u][0][0]=f[u][1][1]=1; for(int i=0;i&lt;g[u].size();i++)&#123; int v=g[u][i]; if(v==fa) continue; dfs(v,u); siz[u]+=siz[v]; memset(tmp,0,sizeof(tmp)); for(int j=0;j&lt;=n;j++)&#123; for(int k=0;k&lt;=siz[v];k++)&#123; if(j-k&gt;=0)&#123; tmp[j][0]+=f[u][j-k][0]*(f[v][k][0]+f[v][k][1])%mod; if(tmp[j][0]&gt;mod) tmp[j][0]-=mod; tmp[j][1]+=f[u][j-k][1]*(f[v][k][0]+f[v][k][1])%mod; if(tmp[j][1]&gt;mod) tmp[j][1]-=mod; &#125; if(j-k+1&gt;=0)&#123; tmp[j][1]+=f[u][j-k+1][1]*f[v][k][1]%mod; if(tmp[j][1]&gt;mod) tmp[j][1]-=mod; &#125; &#125; &#125; memcpy(f[u],tmp,sizeof(tmp)); &#125;&#125;int main()&#123; freopen(\"subtrees.in\",\"r\",stdin); freopen(\"subtrees.out\",\"w\",stdout); scanf(\"%d\",&amp;n); for(int i=1;i&lt;n;i++)&#123; int x,y; scanf(\"%d%d\",&amp;x,&amp;y); g[x].push_back(y); g[y].push_back(x); &#125; dfs(1,0); for(int i=1;i&lt;=n;i++) printf(\"%lld\\n\",(f[1][i][0]+f[1][i][1])%mod); return 0;&#125;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://harmoniikaa.top/tags/动态规划/"},{"name":"模拟","slug":"模拟","permalink":"http://harmoniikaa.top/tags/模拟/"},{"name":"博弈论","slug":"博弈论","permalink":"http://harmoniikaa.top/tags/博弈论/"},{"name":"计算几何","slug":"计算几何","permalink":"http://harmoniikaa.top/tags/计算几何/"},{"name":"树形DP","slug":"树形DP","permalink":"http://harmoniikaa.top/tags/树形DP/"}]},{"title":"GYM 101164","date":"2017-04-17T10:14:54.000Z","path":"2017/04/17/GYM-101164/","text":"2016-2017 ACM-ICPC Southeastern European Regional Programming Contest (SEERC 2016) A Three SquaresB Favorite musicC Castle注意到询问实际上求的是border,是在KMP的next数组上走然后求和的一种形式.然后直接在线KMP做就可以了.123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;#define N 1300000using namespace std;int next[N];int c[N],vis[N];char s[N];int n,m;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); scanf(\"%s\",s+1); for(int i=2;i&lt;=n;i++)&#123; int j=next[i-1]; while(s[j+1]!=s[i]&amp;&amp;j) j=next[j]; if(s[j+1]==s[i]) j++; next[i]=j; &#125; while(m--)&#123; int opt;char ch[10]; scanf(\"%d\",&amp;opt); if(opt==1)&#123; scanf(\"%s\",ch); s[++n]=ch[0]; int j=next[n-1]; while(s[j+1]!=s[n]&amp;&amp;j) j=next[j]; if(s[j+1]==s[n]) j++; next[n]=j; c[n]+=c[j]; &#125; if(opt==2)&#123; if(!vis[n])&#123; c[n]++; vis[n]=1; &#125; &#125; if(opt==3)&#123; printf(\"%d\\n\",c[n]); &#125; &#125; return 0;&#125; D Reading Digits简单模拟 1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;cstring&gt;#define N 300010using namespace std;int k,pos,b[N],a[N],tot;char ch[N];int main()&#123; scanf(\"%d%d\",&amp;k,&amp;pos); scanf(\"%s\",ch); int l=strlen(ch); for(int i=0;i&lt;l;i++) a[i]=ch[i]-'0'; while(k--)&#123; tot=0; for(int i=0;i&lt;l;i+=2)&#123; while(a[i]--)&#123; b[tot++]=a[i+1]; if(tot&gt;2e5)&#123; break; &#125; &#125; &#125; for(int i=0;i&lt;tot;i++) a[i]=b[i]; l=tot; &#125; printf(\"%d\\n\",a[pos]); return 0;&#125; E ExamF Letters简单模拟 123456789101112131415#include&lt;cstdio&gt;using namespace std;int main()&#123; int n,l=1; scanf(\"%d\",&amp;n); for(int p=26;l*p&lt;n;p*=26,l++) n-=p*l; int k=n/l,b=n%l; for(int i=1;i&lt;l-b;i++)&#123; k/=26; &#125; k%=26; printf(\"%c\\n\",'A'+k); return 0;&#125; G Pokemons在线弄一个前缀最小值,然后模拟. 卡内存简单题.123456789101112131415161718192021#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;double s;int n;double mn;int main()&#123; scanf(\"%lf\",&amp;s); scanf(\"%d\",&amp;n); scanf(\"%lf\",&amp;mn); double x,ans=-1e100; for(int i=2;i&lt;=n;i++)&#123; scanf(\"%lf\",&amp;x); ans=max(ans,s/mn*x-s); mn=min(mn,x); &#125; printf(\"%.2f\",ans); return 0;&#125; H Pub crawl计算几何. 事实上所有点都可以被选到,只需要每次选取级角序最小的点就可以了.选出的图形是一个螺旋形.复杂度为$O(n^2)$. 但是因为double的使用,导致代码常数会非常大,所以需要卡常数. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;cmath&gt;#define N 5010#define ll long longusing namespace std;inline int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;struct Point&#123; int x,y; Point(int _=0,int __=0)&#123; x=_;y=__; &#125;&#125;a[N];inline Point operator - (Point A,Point B)&#123; return Point(A.x-B.x,A.y-B.y);&#125;inline double dot(Point A,Point B)&#123; return (double)A.x*B.x+(double)A.y*B.y;&#125;inline double cosine(Point A,Point B)&#123; double t=dot(A,B); return (t&gt;0?1.0:-1.0)*t*t/dot(A,A);&#125;int n;bool vis[N];int p[N]; int getpos(Point A,Point B)&#123; int ret=0;double mn=1e200; Point C=B-A; for(int i=1;i&lt;=n;i++)&#123; if(vis[i]) continue; double now=cosine(a[i]-A,C); if(now&lt;mn)&#123; ret=i; mn=now; &#125; &#125; return ret;&#125;int main()&#123; n=read(); if(n==1)&#123; printf(\"1\\n1\\n\"); return 0; &#125; if(n==2)&#123; printf(\"2\\n1 2\\n\"); return 0; &#125; for(int i=1;i&lt;=n;i++)&#123; a[i].x=read(); a[i].y=read(); &#125; p[1]=1; for(int i=2;i&lt;=n;i++)&#123; if((a[i].y&lt;a[p[1]].y)||((a[i].y==a[p[1]].y)&amp;&amp;(a[i].x&lt;a[p[1]].x)))&#123; p[1]=i; &#125; &#125; a[0].x=a[p[1]].x-1;a[0].y=a[p[1]].y; vis[p[1]]=1; for(int i=2;i&lt;=n;i++)&#123; p[i]=getpos(a[p[i-1]],a[p[i-2]]); vis[p[i]]=1; &#125; printf(\"%d\\n\",n); for(int i=1;i&lt;=n;i++) printf(\"%d \",p[i]); printf(\"\\n\"); return 0;&#125; I Cubes首先有一个比较显然的DP: dp_i=min_{kj^3 \\leq i}{(dp_{i-kj^3} + k)}也有一个比较显然的优化: dp_i=min_{j^3 \\leq i}{(dp_{i-j^3} + 1)}但是复杂度也显然不对. 打一个表后发现每个大于1e6的数最多由6个立方数相加组成,因此DP预处理出前1e6项,剩下的数直接大力map+DFS出解. 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define N 45000010using namespace std;short dp[N];short from[N];int mi[400];int n;int ans[10000],tot;int main()&#123; for(int i=1;i&lt;=370;i++) mi[i]=i*i*i; scanf(\"%d\",&amp;n); memset(dp,0x3f,sizeof(dp)); dp[0]=0;dp[1]=1;from[1]=1; for(register int i=2;i&lt;=n;i++)&#123; for(int j=1;mi[j]&lt;=i;j++)&#123; if(dp[i-mi[j]]+1&lt;dp[i])&#123; dp[i]=dp[i-mi[j]]+1; from[i]=j; &#125; &#125; &#125; for(int i=n;i;i=i-mi[from[i]]) ans[++tot]=from[i]; printf(\"%d\\n\",tot); for(int i=1;i&lt;=tot;i++) printf(\"%d \",ans[i]); printf(\"\\n\"); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define N 2000010using namespace std;short dp[N];short from[N];int mi[400];int n;int ans[20],tot;map&lt;int,int&gt; dpm,fm;int dfs(int i,int dep)&#123; if(i&lt;=2000000)&#123; return dp[i]; &#125; if(dep&gt;2) return 1e9; if(dpm[i])&#123; return dpm[i]; &#125; int ret=1e9,fr; for(int j=1;mi[j]&lt;=i;j++)&#123; int t=dfs(i-mi[j],dep+1)+1; if(t&lt;ret)&#123; ret=t; fr=j; &#125; &#125; fm[i]=fr;dpm[i]=ret; return ret;&#125;int main()&#123; for(int i=1;i&lt;=370;i++) mi[i]=i*i*i; scanf(\"%d\",&amp;n); memset(dp,0x3f,sizeof(dp)); dp[0]=0;dp[1]=1;from[1]=1; for(int i=2;i&lt;=2000000;i++)&#123; for(int j=1;mi[j]&lt;=i;j++)&#123; if(dp[i-mi[j]]+1&lt;dp[i])&#123; dp[i]=dp[i-mi[j]]+1; from[i]=j; &#125; &#125; &#125; if(n&lt;=2000000)&#123; for(int i=n;i;i=i-mi[from[i]]) ans[++tot]=from[i]; &#125;else&#123; dfs(n,0); for(int i=n;i;)&#123; if(i&lt;=2000000)&#123; ans[++tot]=from[i]; i=i-mi[from[i]]; &#125;else&#123; ans[++tot]=fm[i]; i=i-mi[fm[i]]; &#125; &#125; &#125; printf(\"%d\\n\",tot); for(int i=1;i&lt;=tot;i++) printf(\"%d \",ans[i]); printf(\"\\n\"); return 0;&#125; J MarathonK Cutting枚举断点,HASH判定即可.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define N 5010#define ll long long#define mod 1000000123ll#define P 521llusing namespace std;char a[N],b[N];ll p[N],h[N];int n;ll gethash(int l,int r)&#123; return (h[r]-h[l-1]*p[r-l+1]%mod+mod)%mod;&#125;void print(int l,int r)&#123; for(int i=l;i&lt;=r;i++)&#123; printf(\"%c\",b[i]); &#125; printf(\"\\n\");&#125;int main()&#123; p[0]=1; for(int i=1;i&lt;=5000;i++) p[i]=p[i-1]*P%mod; scanf(\"%s\",a+1); scanf(\"%s\",b+1); n=strlen(a+1); ll ha=0; for(int i=1;i&lt;=n;i++) ha=(ha*P%mod+a[i])%mod; for(int i=1;i&lt;=n;i++) h[i]=(h[i-1]*P+b[i])%mod; for(int i=1;i&lt;n-1;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; ll A=gethash(1,i),B=gethash(i+1,j),C=gethash(j+1,n); int la=i,lb=j-i,lc=n-j; if((p[lb+lc]*A%mod+p[lc]*B%mod+C)%mod==ha)&#123; printf(\"YES\\n\"); print(1,i); print(i+1,j); print(j+1,n); return 0; &#125; if((p[lb+lc]*A%mod+p[lb]*C%mod+B)%mod==ha)&#123; printf(\"YES\\n\"); print(1,i); print(j+1,n); print(i+1,j); return 0; &#125; if((p[la+lc]*B%mod+p[lc]*A%mod+C)%mod==ha)&#123; printf(\"YES\\n\"); print(i+1,j); print(1,i); print(j+1,n); return 0; &#125; if((p[la+lc]*B%mod+p[la]*C%mod+A)%mod==ha)&#123; printf(\"YES\\n\"); print(i+1,j); print(j+1,n); print(1,i); return 0; &#125; if((p[la+lb]*C%mod+p[lb]*A%mod+B)%mod==ha)&#123; printf(\"YES\\n\"); print(j+1,n); print(1,i); print(i+1,j); return 0; &#125; if((p[la+lb]*C%mod+p[la]*B%mod+A)%mod==ha)&#123; printf(\"YES\\n\"); print(j+1,n); print(i+1,j); print(1,i); return 0; &#125; &#125; &#125; printf(\"NO\\n\"); return 0;&#125;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://harmoniikaa.top/tags/动态规划/"},{"name":"模拟","slug":"模拟","permalink":"http://harmoniikaa.top/tags/模拟/"},{"name":"计算几何","slug":"计算几何","permalink":"http://harmoniikaa.top/tags/计算几何/"},{"name":"KMP","slug":"KMP","permalink":"http://harmoniikaa.top/tags/KMP/"},{"name":"HASH","slug":"HASH","permalink":"http://harmoniikaa.top/tags/HASH/"}]},{"title":"Codeforces 800D","date":"2017-04-17T06:06:56.000Z","path":"2017/04/17/Codeforces-800D/","text":"发现$G(x)=x*…$,然后再将所有$G(x)$异或到一起,那么感觉上必须先把所有$G(x)$求出来再继续进行.所以$G(x)$前面乘上的那个x可以先忽略不计. 先以样例为例,考虑$G(x)$统计时与哪些集合有关:将此三个数分别设为a,b,c,则有: G(x) S 123 a,ac 321 b,bc 121 ab,abc 555 c 显然这些数并不好统计进$G(x)$,因此不妨设$g(x)=\\sum_{x’ \\leq x}{G(x’)}$,这里的大于等于号表示$x’$的每一位均大于等于$x$的每一位.则有新的$g(x)$: g(x) S 123 a,c,ac 321 b,c,bc 121 a,b,c,ab,bc,ac,abc 555 c 如此看起来就要好统计地多了,$g(x)$将由所有大于等于x的$g(x’)$转移而来.假设大于等于x的所有数有$c(x)$个,和为$s(x)$,平方的和为$s2(x)$,则有$g(x)=2^{c(x)-2}(s2(x)+s(x)^2)$,简单容斥一下就可以推的出来. 由上可以求出$g(x)$在0..999999上的值,思考$g(x)$的定义,可以枚举子集,利用容斥原理得到$G(x)$的值等于有6个数大于等于x的-有5个数+有4个数-….则本题得解. 细节比较多,需要认真考虑. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#define ll long long#define mod 1000000007ll#define N 1000010using namespace std;int n;ll c[N],s[N],s2[N],bin[N],g[N],G[N];int main()&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++)&#123; ll x; scanf(\"%lld\",&amp;x); c[x]++;s[x]+=x;s2[x]+=x*x%mod; &#125; bin[0]=1; for(int i=1;i&lt;=n;i++) bin[i]=bin[i-1]*2%mod; for(int i=1;i&lt;1e6;i*=10)&#123; for(int j=1e6-1;j&gt;=0;j--)&#123; if((j/i)%10!=9)&#123; c[j]+=c[j+i]; c[j]%=mod; s[j]+=s[j+i]; s[j]%=mod; s2[j]+=s2[j+i]; s2[j]%=mod; &#125; &#125; &#125; for(int j=0;j&lt;1e6;j++)&#123; if(c[j]==0) continue; if(c[j]==1) g[j]=s2[j]; else g[j]=bin[c[j]-2]*(s2[j]+s[j]*s[j]%mod)%mod; &#125; for(int i=0;i&lt;1e6;i++)&#123; for(int S=0;S&lt;64;S++)&#123; bool b=1; for(int k=0,p=1;k&lt;6;k++,p*=10)&#123; if((S&amp;(1&lt;&lt;k))&amp;&amp;((i/p)%10==9))&#123; b=0; break; &#125; &#125; if(!b) continue; ll d=1,r=i; for(int k=0,p=1;k&lt;6;k++,p*=10)&#123; if((S&amp;(1&lt;&lt;k))&amp;&amp;((i/p)%10!=9))&#123; d=d*-1; r+=p; &#125; &#125; G[i]+=d*g[r]; &#125; G[i]%=mod; G[i]=(G[i]+mod)%mod; &#125; ll ret=0; for(int i=0;i&lt;1e6;i++)&#123; ret^=(1ll*i*G[i]); &#125; printf(\"%lld\\n\",ret); return 0;&#125;","tags":[{"name":"递推","slug":"递推","permalink":"http://harmoniikaa.top/tags/递推/"},{"name":"容斥原理","slug":"容斥原理","permalink":"http://harmoniikaa.top/tags/容斥原理/"}]},{"title":"Codeforces 800C","date":"2017-04-17T02:55:55.000Z","path":"2017/04/17/Codeforces-800C/","text":"先来考虑在什么情况下存在一个x使得$ax \\equiv b (\\bmod m)$. 首先,如果a与m互质,那么一定存在一个x满足条件无疑. 如果a与m不互质,因为当$k|m$,$k|a$且$k|b$有$\\frac{a}{k}x \\equiv \\frac{b}{k} (\\bmod \\frac{m}{k})$成立.而且只有当$k=gcd(a,m)$时,存在逆元.因此如果$gcd(a,m)|gcd(b,m)$,则存在一个解. 因此DP处理出应该选哪些k作为gcd,然后用exgcd来进行转移即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#define N 200010#define ll long longusing namespace std;int gcd(int a,int b)&#123; return b==0?a:gcd(b,a%b);&#125;void exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(b==0)&#123; x=1;y=0; return; &#125; exgcd(b,a%b,x,y); ll t=x;x=y;y=t-a/b*y;&#125;int n,m;int vis[N],g[N],c[N],p[N];int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; int x; scanf(\"%d\",&amp;x); vis[x]=1; &#125; for(int i=1;i&lt;m;i++)&#123; g[i]=gcd(i,m); if(vis[i]==0) c[g[i]]++; &#125; for(int i=m-1;i&gt;=1;i--)&#123; for(int j=i+i;j&lt;m;j+=i)&#123; if(c[j]&gt;c[p[i]]) p[i]=j; &#125; c[i]+=c[p[i]]; &#125; if(vis[0]==0) c[1]++; printf(\"%d\\n\",c[1]); ll a=1,pre=1;; for(int k=1;k;k=p[k])&#123; for(int i=1;i&lt;m;i++)&#123; if(g[i]==k&amp;&amp;vis[i]==0)&#123; ll x,y; exgcd(a,m,x,y); x=(x%m+m)%m; x=(x*i/pre)%m; pre=k; a=a*x%m; printf(\"%lld \",x); &#125; &#125; &#125; if(vis[0]==0) printf(\"0\\n\"); return 0;&#125;","tags":[{"name":"数论","slug":"数论","permalink":"http://harmoniikaa.top/tags/数论/"},{"name":"拓展欧几里得","slug":"拓展欧几里得","permalink":"http://harmoniikaa.top/tags/拓展欧几里得/"}]},{"title":"Codeforces 797F","date":"2017-04-16T15:17:05.000Z","path":"2017/04/16/Codeforces-797F/","text":"首先一个显然的思路,是连边跑费用流.但是边数过大存不下所以肯定不行. 所以考虑DP:先将mice和hole升序排序,令$dp_{i,j}$表示前i只mice放进前j个hole的最小代价,并且最后一只mouse一定被放进了第j个hole.枚举最后有多少个mice被同时放进第j个hole进行转移,可以建出DP方程: dp_{i,j}=min_{i-c_j \\leq k \\leq i-1,0 \\leq l \\leq j-1}{ dp_{j,l} + cost(k + 1, i, j) }其中cost(l,r,j)表示将第l到第r只mice放进第j个洞所需的代价,可以在转移的同时求出. 这样的DP是$O(n^2m^2)$的,显然跑不过. 考虑另外一种状态表示形式:令$dp_i$表示只考虑前i只mice放进洞里所需的最小代价,然后顺序枚举洞,倒序枚举mouse来转移: dp_i = min_{i-c_j \\leq k \\leq i-1}{dp_k + cost(k+1,i,j)}这样DP复杂度为$O(n^2m)$,经验证可以跑过47个点. 事实上分析可知,在枚举k进行转移的时候,i与i+1的决策点是具有单调性的.然后可以直接利用决策单调性来优化DP,复杂度就可以达到$O(nm)$了. 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define Pair pair&lt;int,int&gt;#define N 5010#define ll long long#define inf 0x3f3f3f3f3f3f3f3fllusing namespace std;int n,m,sum;int x[N];Pair y[N];ll dp[N];int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;x[i]); for(int i=1;i&lt;=m;i++)&#123; scanf(\"%d%d\",&amp;y[i].first,&amp;y[i].second); sum+=y[i].second; &#125; if(sum&lt;n)&#123; printf(\"-1\"); return 0; &#125; sort(x+1,x+1+n);sort(y+1,y+1+m); dp[0]=0; for(int i=1;i&lt;=n;i++) dp[i]=inf; for(int j=1;j&lt;=m;j++)&#123; int c=y[j].second,pos=y[j].first; for(int i=n;i&gt;=1;i--)&#123; ll cost=0; for(int k=i-1;k&gt;=max(0,i-c);k--)&#123; cost+=abs(x[k+1]-pos); dp[i]=min(dp[i],dp[k]+cost); &#125; &#125; &#125; printf(\"%lld\\n\",dp[n]); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define Pair pair&lt;int,int&gt;#define N 5010#define ll long long#define inf 1e18using namespace std;int n,m,sum;int x[N];Pair y[N];ll dp[N],f[N];int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;x[i]); for(int i=1;i&lt;=m;i++)&#123; scanf(\"%d%d\",&amp;y[i].first,&amp;y[i].second); sum+=y[i].second; &#125; if(sum&lt;n)&#123; printf(\"-1\"); return 0; &#125; sort(x+1,x+1+n);sort(y+1,y+1+m); dp[0]=0;sum=0; for(int i=1;i&lt;=n;i++) dp[i]=inf; for(int j=1;j&lt;=m;j++)&#123; int c=y[j].second,pos=y[j].first,p=0; ll cost=0;sum+=c; for(int i=0;i&lt;=n;i++) f[i]=dp[i]; for(int i=1;i&lt;=min(sum,n);i++)&#123; cost+=abs(x[i]-pos); while(((dp[p]+cost&gt;dp[p+1]+cost-abs(x[p+1]-pos))&amp;&amp;(p+1&lt;i))||(p&lt;i-c))&#123; p++; cost-=abs(x[p]-pos); &#125; f[i]=dp[p]+cost; &#125; for(int i=0;i&lt;=n;i++) dp[i]=min(dp[i],f[i]); &#125; printf(\"%lld\\n\",dp[n]); return 0;&#125;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://harmoniikaa.top/tags/动态规划/"}]},{"title":"Codeforces 736A","date":"2017-04-16T02:13:56.000Z","path":"2017/04/16/Codeforces-736A/","text":"考虑如果要造出一个打过i场的胜利者,需要先造出一个打过i-1场的和一个打过i-2场的.假设要造出一个打过i场的胜利者最少需要$f_i$个人参加比赛,则有: $f_i = f_{i-1} + f_{i-2}$.初始时$f_0 = 1, f_1 = 2$,当$f_i$第一次大于n时,i-1即是答案. 12345678910111213141516171819#include&lt;cstdio&gt;#define ll long longusing namespace std;ll f[100];ll n;int main()&#123; scanf(\"%lld\",&amp;n); f[0]=1;f[1]=2; for(int i=2;;i++)&#123; f[i]=f[i-1]+f[i-2]; if(f[i]&gt;n)&#123; printf(\"%d\\n\",i-1); return 0; &#125; &#125; return 0;&#125;","tags":[{"name":"递推","slug":"递推","permalink":"http://harmoniikaa.top/tags/递推/"}]},{"title":"Codeforces 797E","date":"2017-04-15T17:08:34.000Z","path":"2017/04/16/Codeforces-797E/","text":"考虑$n,q \\leq1e5$,可以考虑使用根号算法在$O(\\sqrt n)$的时间内完成单次询问. 所以将询问分类讨论,当$k \\leq \\sqrt n$时,对于每一个k暴力DP求解.当$k \\geq \\sqrt n$时,直接暴力求解即可. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;climits&gt;#define rep(i,a,b) for(int i=(a);i&lt;=(b);i++)#define per(i,a,b) for(int i=(a);i&gt;=(b);i--)#define inf 0x3f3f3f3f#define N 100010#define M using namespace std;inline int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;struct Query&#123; int q,k,ans,ord;&#125;q[N];int n,m,a[N],f[N];bool cmp(Query A,Query B)&#123; return A.k&lt;B.k;&#125;bool recmp(Query A,Query B)&#123; return A.ord&lt;B.ord;&#125;void dp(int k)&#123; per(i,n,1)&#123; if(i+a[i]+k&lt;=n)&#123; f[i]=f[i+a[i]+k]+1; &#125;else&#123; f[i]=1; &#125; &#125;&#125;int main()&#123; n=read(); rep(i,1,n) a[i]=read(); m=read(); rep(i,1,m) q[i].q=read(),q[i].k=read(),q[i].ord=i; sort(q+1,q+1+m,cmp); rep(i,1,m)&#123; if(q[i].k&gt;300)&#123; int ans=0,x=q[i].q; while(x&lt;=n)&#123; x=x+a[x]+q[i].k; ans++; &#125; q[i].ans=ans; &#125;else&#123; if(q[i].k==q[i-1].k)&#123; q[i].ans=f[q[i].q]; &#125;else&#123; dp(q[i].k); q[i].ans=f[q[i].q]; &#125; &#125; &#125; sort(q+1,q+1+m,recmp); rep(i,1,m) printf(\"%d\\n\",q[i].ans); return 0;&#125;","tags":[{"name":"分块","slug":"分块","permalink":"http://harmoniikaa.top/tags/分块/"}]},{"title":"Hello World","date":"2017-04-15T14:21:54.000Z","path":"2017/04/15/Hello-World/","text":"Hello world!","tags":[{"name":"随笔","slug":"随笔","permalink":"http://harmoniikaa.top/tags/随笔/"}]}]